node {
    env.APP_NAME = "PyGoat"
    
    try {
        stage('Checkout SCM') {
            checkout scm
        }

        stage('SAST - Bandit') {
            sh '''
              docker run --rm -v "$PWD":/src -w /src python:3.11-slim \
                sh -c "pip install --no-cache-dir bandit && bandit -r . -f json -o bandit-report.json --exit-zero"
            '''
        }

        stage('Upload Bandit to DefectDojo') {
            withCredentials([
                string(credentialsId: 'DEFECTDOJO_API_KEY', variable: 'DD_API_KEY'),
                string(credentialsId: 'DEFECTDOJO_URL', variable: 'DD_URL')
            ]) {
                sh '''
                  # Añadimos host-gateway para mapear host.docker.internal a la IP del host
                  docker run --rm --network host \
                    --add-host=host.docker.internal:host-gateway \
                    -v "$PWD":/work alpine:3.19 sh -c "
                      apk add --no-cache curl > /dev/null && \
                      echo '--- Intentando conectar a: $DD_URL ---' && \
                      curl -v -X POST '${DD_URL}/api/v2/import-scan/' \
                        -H 'Authorization: Token ${DD_API_KEY}' \
                        -F 'scan_type=Bandit Scan' \
                        -F 'product_name=${APP_NAME}' \
                        -F 'engagement_name=${APP_NAME} CI/CD' \
                        -F 'file=@/work/bandit-report.json' \
                        -F 'active=true' \
                        -F 'verified=false'"
                '''
            }
        }
        
        // ... (Resto de etapas mantendrían la misma lógica de red)
        
    } catch (Exception e) {
        currentBuild.result = 'FAILURE'
        echo "Error detallado: ${e.getMessage()}"
    } finally {
        archiveArtifacts artifacts: '*.json', allowEmptyArchive: true
    }
}
